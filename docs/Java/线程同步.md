# 线程同步

> `线程同步可以有效避免多个线程访问共享资源时产生的冲突和不一致问题，从而确保程序的正确性。过多的同步也可能降低程序的性能，使用线程同步需要权衡性能和正确性`

## 1 synchronized 

> `保证多线程访问共享资源时的安全性和一致性`

当一个线程进入 `synchronized` 块时，它会尝试获取锁，如果该锁被其他线程持有，则该线程就会被阻塞，直到该锁被释放。
当一个线程退出 `synchronized` 块时，它会释放持有的锁，从而允许其他线程进入该块

每个对象都有一个监视器`（monitor）`锁
当一个线程进入 `synchronized` 块时，它获取该对象的监视器锁
只有该线程持有该锁时，其他线程才无法进入该块
Java 的内存模型保证，一个线程释放锁之前，对共享变量所做的修改都将立即对其他线程可见

## 2 AQS

> `AbstractQueuedSynchronizer` 是 Java 中实现锁的基础框架，提供了一种实现同步状态的机制。
> `AQS` 的实现主要依赖于两个类：`Node` 和 `Sync`

### `Node`

`AQS` 中的一个内部类，用于表示一个等待获取锁的线程。在 `Node` 中，包含了线程的状态（`CANCELLED`、`SIGNAL`、`CONDITION`、`PROPAGATE`、0），以及等待队列中的`前驱节点`、`后继节点`等信息。

### `Sync`

`AQS` 的抽象类，它定义了 `AQS` 的主要接口和状态，是 `AQS` 实现的核心。在 `Sync` 中，定义了一系列方法，用于实现锁的获取和释放，包括`tryAcquire` `tryRelease` `acquire` `release` 

### `实现锁的方式`

`AQS`通过维护一个 `FIFO` 的等待队列，来实现锁的获取和释放。当一个线程请求获取锁时，如果锁已经被占用，那么线程就会被加入等待队列中，然后自旋等待锁的释放。当锁被释放时，`AQS` 会从等待队列中取出一个线程，并唤醒它，使其重新尝试获取锁。

1. 尝试获取锁：`tryAcquire` 尝试获取锁，并返回是否获取成功。
2. 获取成功：直接返回。
3. 获取失败：将当前线程封装成一个 `Node`，并加入等待队列中
4. 自旋等待：如果当前线程的前驱节点是头节点，并且当前线程成功获取到锁，就将当前线程设置为头节点，然后唤醒后继节点，使其重新尝试获取锁。
5. 释放锁：`tryRelease` 方法会释放锁，并返回是否释放成功。
6. 释放成功：尝试唤醒等待队列中的下一个节点。

AQS提供了一种通用的同步状态机制，可以用于实现多种不同的锁和同步工具
例如 `ReentrantLock` `Semaphore` `CountDownLatch`
