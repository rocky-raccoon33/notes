# 软件设计原则

## 1 开闭原则 `Open Closed Principle，OCP`

> **软件实体应当对扩展开放，对修改关闭。即：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求**

- 对软件测试的影响
- 提高代码的可复用性
- 提高软件的可维护性

## 2 里氏替换原则 `Liskov Substitution Principle，LSP`

> **继承必须确保基类所拥有的性质在子类中仍然成立。即：子类可以扩展父类的功能，但不能改变父类原有的功能**

- 是实现开闭原则的重要方式之一
- 克服了继承中重写父类造成的可复用性变差的缺点
- 类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性

## 3 依赖倒置原则 `Dependence Inversion Principle，DIP`

> **要面向接口编程，不要面向实现编程。即：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。**

- 可以降低类间的耦合性
- 可以减少并行开发引起的风险
- 可以提高代码的可读性和可维护性

## 4 单一职责原则 `Single Responsibility Principle，SRP`

> **单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分，如果一个对象承担了太多的职责，至少存在以下两个缺点：**

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

___

- 降低类的复杂度
- 提高类的可读性。
- 提高系统的可维护性
- 变更引起的风险降低。

## 5 接口隔离原则

> **客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上**
___
> **与单一职责原则的区别**

1. 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
2. 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

___

- 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
- 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
- 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
- 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码

## 6 迪米特法则 `Law of Demeter，LoD, 又叫作最少知识原则（Least Knowledge Principle，LKP`

> **如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性**

- 降低了类之间的耦合度，提高了模块的相对独立性。
- 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

## 7 合成复用原则 `Composite Reuse Principle，CRP, 又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP`

> **在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现**
___
> **通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点:**

1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化

> **采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点:**

1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

