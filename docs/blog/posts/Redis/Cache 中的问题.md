
## 1 数据一致性

### `1.1` 单机读写

> `方案A`：删除缓存 THEN 更新数据库

并发「读写」数据：

1. 线程 A 要更新 `X = 2` [`db:X = 1`]
2. 线程 A 先删除缓存
3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值 `X = 1`
4. 线程 A 将新值写入数据库 `X = 2`
5. 线程 B 将旧值写入缓存 `X = 1`

在线程A更新完数据库值以后，可以让它先 `sleep` 一小段时间，再进行一次缓存删除操作

```java
redis.delKey(X)
db.update(X)
Thread.sleep(N)
redis.delKey(X)
```

___

> `方案B`： 更新数据库 THEN 删除缓存

并发「读写」数据：

1. 缓存中 X 不存在 [`db:X = 1`]
2. 线程 A 读取数据库，得到旧值 `X = 1`
3. 线程 B 更新数据库 `X = 2`，删除缓存
4. 线程 A 将旧值写入缓存 `X = 1`

`方案B`发生的概率低，需要满足：

1. 缓存刚好已失效
2. 读 + 写并发
3. 更新数据库 + 删除缓存的时间 < 要比读数据库 + 写缓存时间短 `[X]`

其他线程读取时，会发生缓存缺失，进而从数据库读取新值，对业务影响较小

> 保证两步均成功：`异步重试？`

1. 异步串行
2. 配合 「消息队列」 或 「订阅变更日志」

### `1.2` 「读写分离 + 主从复制延迟」

1. 线程 A 更新主库 `X = 2` [`主库：X = 1`]，删除缓存
2. 线程 B 查询缓存，没有命中，查询「从库」得到旧值 [`从库：X = 1`]
3. 从库「同步」完成 [`主从库：X = 2`]
4. 线程 B 将「旧值」写入缓存 `X = 1`

`延迟双删`：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存

结论：{== 先更新数据库，再删除缓存 ==}

## 2 异常情况

### `2.1` 缓存雪崩

由两个原因导致：

> 缓存中的大量数据同时过期，导致大量请求无法得到处理

- 微调过期时间
- 服务降级

> 缓存实例宕机

- 业务系统中实现服务熔断或请求限流机制，暂停对缓存服务的访问
- 高可用缓存，主从集群 「哨兵」

## `2.2` 缓存击穿

1. 针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，经常发生在热点数据过期失效时

- 对于访问特别频繁的热点数据，不设置过期时间，一直保留

## `2.3` 缓存穿透

1. 缓存穿透是指要访问的数据既不在Redis缓存中，也不在数据库中

两种情况导致：

- 业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据
- 恶意攻击：专门访问数据库中没有的数据

解决方案：

- 缓存空值或缺省值
- 利用布隆过滤器快速判断
- 前端入口对请求合法性进行判断

## 参考

- [1] [A Hitchhiker’s Guide to Caching Patterns](https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/)

