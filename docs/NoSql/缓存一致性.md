# 缓存 / 数据库 一致性

## `1` 单机读写

> `方案A`：删除缓存 THEN 更新数据库

并发「读写」数据：

1. 线程 A 要更新 `X = 2` [`db:X = 1`]
2. 线程 A 先删除缓存
3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值 `X = 1`
4. 线程 A 将新值写入数据库 `X = 2`
5. 线程 B 将旧值写入缓存 `X = 1`

在线程A更新完数据库值以后，可以让它先 `sleep` 一小段时间，再进行一次缓存删除操作

```java
redis.delKey(X)
db.update(X)
Thread.sleep(N)
redis.delKey(X)
```

___

> `方案B`： 更新数据库 THEN 删除缓存

并发「读写」数据：

1. 缓存中 X 不存在 [`db:X = 1`]
2. 线程 A 读取数据库，得到旧值 `X = 1`
3. 线程 B 更新数据库 `X = 2`，删除缓存
4. 线程 A 将旧值写入缓存 `X = 1`

`方案B`发生的概率低，需要满足：

1. 缓存刚好已失效
2. 读 + 写并发
3. 更新数据库 + 删除缓存的时间 < 要比读数据库 + 写缓存时间短 `[X]`

其他线程读取时，会发生缓存缺失，进而从数据库读取新值，对业务影响较小

> 保证两步均成功：`异步重试？`

1. 异步串行
2. 配合 「消息队列」 或 「订阅变更日志」

## `2` 「读写分离 + 主从复制延迟」

线程 A 更新主库 `X = 2` [`主库：X = 1`]，删除缓存
线程 B 查询缓存，没有命中，查询「从库」得到旧值 [`从库：X = 1`]
从库「同步」完成 [`主从库：X = 2`]
线程 B 将「旧值」写入缓存 `X = 1`

`延迟双删`：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存

结论：{==先更新数据库，再删除缓存==}
